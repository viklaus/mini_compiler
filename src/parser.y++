%{
    #include "ast.h"
    #include "codegen.h"
    #include<iostream>
    #include<stdio.h>
    #include <fstream>
    using namespace std;
    
    extern char* yytext;
    extern int line;
    extern vector<quad> code;
	vector<string>par;

    extern void yyerror(char const*);
    extern void print3AC();
    int yylex (void); 

    FILE* dotfile;
	ofstream code_file;
    stack<int> block_stack;

    int func_flag = 0;
    int dump_tac = 1;  // testing
    int dump_sym_table = 1; // testing
    int block_count = 0;
    int if_found = 0;
	int isArray = 0;
    int previous_if_found = 0;
    int stop_compiler = 0;		// shows error while parsing
    int type_delim = 0;	
	int debug_mode = 0;		

    string funcName = "";
    string className = "";
    string funcType = "";
    string classTemp ="";
    string type = "";
    string storage_class = "";
    vector<string> funcArgs;
    vector<string> idList;
    vector<vector<string> > currArgs(1,vector<string>() );
    vector<qid> initializer_list_values;
    vector<int> array_dims;
    map<string, vector<int>> gotolablelist;
    map<string, int> gotolabel;
    map<string, int> func_usage_map;
    map<string, vector<qid>> global_array_init_map;
    void set_int_type(int);
    void set_real_type();
    int char_int(string str);
    #define YYDEBUG 1
    #define YYERROR_VERBOSE

%}

%union { 
    char* str;
    treeNode* ptr;
    constants* num;
    int ind;
}

%left<str> '(' ')' '{' '}' '[' ']' '.' '+' '-' '*' '/' '%' '&' '|' '^' ',' ';' '<' '>'
%right<str> '~' '!' '?' ':' '=' 
%left<str>  RIGHT_OP LEFT_OP EQ_OP NE_OP  AND_OP OR_OP  LE_OP GE_OP  
%right<str> ADD_ASSIGN SUB_ASSIGN MUL_ASSIGN DIV_ASSIGN MOD_ASSIGN LEFT_ASSIGN RIGHT_ASSIGN AND_ASSIGN XOR_ASSIGN OR_ASSIGN UNSIGNED_RIGHT UNSIGNED_RIGHT_ASSIGN

%token<str>integerLiteral stringLiteral nullLiteral characterLiteral textBlock booleanLiteral FloatingPointLiteral Identifier CONTINUE FOR NEW IF PACKAGE BOOLEAN PRIVATE THIS BREAK DOUBLE THROW BYTE ELSE PUBLIC RETURN INT SHORT CHAR FINAL STATIC VOID CLASS LONG FLOAT WHILE _ YIELD eof INC_OP DEC_OP 
%type<ind> NEXT_QUAD

%type<ptr> S G A ChangeTable 
%type<ind> WRITE_GOTO
%type<ptr> AdditiveExpression Name AndExpression ArgumentList ArrayAccess ArrayCreationExpression Assignment AssignmentExpression AssignmentOperator Block BlockStatement BlockStatements BreakStatement CastExpression ClassBody ClassBodyDeclaration ClassDeclaration ClassInstanceCreationExpression ClassOrInterfaceTypeToInstantiate CompilationUnit ConditionalAndExpression ConditionalExpression ConditionalOrExpression ConstructorBody ConstructorDeclaration ContinueStatement DimExpr DimExprs Dims EqualityExpression ExclusiveOrExpression ExplicitConstructorInvocation Expression ExpressionStatement  FieldDeclaration FloatingPointType ForInit FormalParameter FormalParameterList ForStatement ForStatementNoShortIf ForUpdate  IfThenElseStatement IfThenElseStatementNoShortIf IfThenStatement InclusiveOrExpression IntegralType LabeledStatement LabeledStatementNoShortIf  Literal LocalVariableDeclaration MethodBody MethodDeclaration MethodHeader MethodInvocation MultiplicativeExpression NumericType OrdinaryCompilationUnit PostDecrementExpression PostfixExpression PostIncrementExpression PreDecrementExpression PreIncrementExpression Primary PrimaryNoNewArray PrimitiveType RelationalExpression ReturnStatement ShiftExpression Statement StatementExpression StatementExpressionList StatementNoShortIf StatementWithoutTrailingSubstatement StaticInitializer ThrowStatement TopLevelClassOrInterfaceDeclaration TopLevelClassOrInterfaceDeclarations  TypeArgumentsOrDiamond UnaryExpression UnaryExpressionNotPlusMinus UnqualifiedClassInstanceCreationExpression VariableDeclaratorList VariableInitializer WhileStatement WhileStatementNoShortIf ClassBodyDeclarations Dimsy ArgumentListy ClassBodyy BasicForHeader EnhancedForHeader ForInity Expressiony ForUpdatey TypeArgumentsOrDiamondy ClassOrInterfaceTypeToInstant  Modifiers Modifier SimpleName QualifiedName LeftHandSide VOID2 MethodorConstrDeclarator VariableDeclarator Declarator SimpleName2 Declaration_list IF_CODE EXPR_CODE GOTO_COND GOTO_OR GOTO_AND N

%start CompilationUnit

%%

//grammar for chapter 4

Literal
    : integerLiteral {
        $$=makeleaf($1);
        $$->type = string("int");
        $$->intVal = stoi(string($1));
        $$->expType = 4;
        $$->tempName = string($1);
		sym_entry* temp = new sym_entry;
		$$->place = qid($1, temp);
		$$->nextlist.clear();
    }
    | FloatingPointLiteral {
        $$=makeleaf($1);
        $$->type = string("float");
        $$->realVal = stod(string($1));
        $$->expType = 4;
        $$->tempName = string($1);
		sym_entry* temp = new sym_entry;
		$$->place = qid($1, temp);
		$$->nextlist.clear();

    }
    | booleanLiteral {
        $$=makeleaf($1);
        $$->type = string("boolean");
        if(string($1) == "true") $$->intVal = 1;
        else $$->intVal = 0;
        $$->strVal = string($1);
        $$->expType = 4;
        $$->tempName = string($1);
		sym_entry* temp = new sym_entry;
		$$->place = qid($1, temp);
		$$->nextlist.clear();
    }
    | characterLiteral {
        $$=makeleaf($1);
        $$->type = string("char");
        $$->intVal = char_int(string($1));
        $$->expType = 4;
        $$->tempName = string($1);
		sym_entry* temp = new sym_entry;
		$$->place = qid($1, temp);
		$$->nextlist.clear();
    }
    | stringLiteral {
        $$=makeleaf($1);
        $$->type = string("string");
        $$->strVal = string($1);
        $$->expType = 4;
        $$->tempName = string($1);
		sym_entry* temp = new sym_entry;
		$$->place = qid($1, temp);
		$$->nextlist.clear();
    }
    | textBlock {
        $$=makeleaf($1);
        $$->type = string("textblock");
        $$->tbval = $1;
        $$->expType = 4;
		sym_entry* temp = new sym_entry;
		$$->place = qid($1, temp);
		$$->nextlist.clear();
    }
    | nullLiteral {
        $$=makeleaf($1);
        $$->type = string("null");
        $$->expType = 4;
        $$->tempName = string($1);
		sym_entry* temp = new sym_entry;
		$$->place = qid($1, temp);
		$$->nextlist.clear();
    }
    ;


PrimitiveType
    : NumericType {
        type = $1->type;
        $$ = $1;
	}
    | BOOLEAN {
        $$ = makeleaf($1);

        // Semantics
        type = $1;
        $$->type = $1;
    }
    ;


NumericType
    : IntegralType {
        $$ = $1;
    }
    | FloatingPointType {
        $$ = $1 ;
    }
    ;

IntegralType   
    : BYTE {
        $$ = makeleaf($1);

        // Semantics
		if(type == "") type = string($1);
		else if(!type_delim) type += " " + string($1);
		$$->type = $1;

    }
    | SHORT {
        $$ = makeleaf($1);

        // Semantics
		if(type == "") type = string($1);
		else if(!type_delim) type += " " + string($1);
		$$->type = $1;
    }
    | INT {
        $$ = makeleaf($1);

        // Semantics
		if(type == "") type = string($1);
		else if(!type_delim) type += " " + string($1);
		$$->type = $1;
    }
    | LONG {
        $$ = makeleaf($1);

        // Semantics
		if(type == "") type = string($1);
		else if(!type_delim) type += " " + string($1);
		$$->type = $1;
    }
    | CHAR {
        $$ = makeleaf($1);

        // Semantics
		if(type == "") type = string($1);
		else if(!type_delim) type += " " + string($1);
		$$->type = $1;
    }
    ;

FloatingPointType
    : FLOAT {
        $$ = makeleaf($1);

        // Semantics
		if(type == "") type = string($1);
		else if(!type_delim) type += " " + string($1);
		$$->type = $1;
    }
    | DOUBLE {
        $$ = makeleaf($1);

        // Semantics
		if(type == "") type = string($1);
		else if(!type_delim) type += " " + string($1);
		$$->type = $1;
    }
    ;

Dims
    :'['']'{
        vector<data2>v;
        insertAttr(v, NULL, "[", 0);
        insertAttr(v, NULL, "]", 0);
		$$ = makenode("Dims", v);

        // Semantics
		$$->expType = 2;
        $$->type = "*";

    }
    |'[' ']' Dims{
        vector<data2>v;
        insertAttr(v, NULL, "[", 0);
        insertAttr(v, NULL, "]", 0);
        insertAttr(v, $3, "", 1);
		$$ = makenode("Dims", v);

        // Semantics
        if(!$3->is_error){
            $$->expType = 2;
            $$->type = $3->type + "*";
        }
        else {
            $$->is_error = 1;
        }
    }
    ;

//Grammar for Names

Name
    :SimpleName{$$=$1;}
    |QualifiedName{$$=$1;}

SimpleName
    :Identifier{
        $$=makeleaf($1);

        // Semantics
		cout << "in Simplename\n";
		string temp = primaryExpression(string($1));  
		// if type is there in the symbol table then this means the variable is already declared
		if(temp == ""){
			yyerror(("Undeclared Identifier " + string($1)).c_str());
		}
		else{
			if(temp.substr(0, 5) == "FUNC_"){
				$$->expType = 3;
			}
			else
			{
				if((*curr_table)[string($1)]->init == 0){
					yyerror("Uninitialized variable used ");
				}
				if(temp.back() == '*'){
					$$->expType = 2; 
				}
				else $$->expType = 1;
			}

			if(temp.substr(0,5)=="FUNC_" && temp.back() == '#'){
				temp.pop_back();
				$$->type = temp;
				$$->tempName = string($1); 

                // --3AC 
				$$->nextlist.clear();
			}
			else{

				$$->type = temp;
				$$->isInit = lookup(string($1))->init;
				$$->size = getSize(temp);
				$$->tempName = string($1); 
				
				//--3AC
				$$->place = qid(string($1), lookup(string($1)));
				$$->nextlist.clear();

			}
		}
    }

QualifiedName
    :Name '.' SimpleName{
        vector<data2>v;
        insertAttr(v, $1, "", 1);
        insertAttr(v,NULL,".",0);
        insertAttr(v, $3, "", 1);
		$$ = makenode("Name.id", v);

        //Semantics
		if(!$1->is_error && $1->expType!=4){
			string temp = string($3->tempName);
			int ret = findTypeAttr($1->type,temp);
			if(ret == -1){
				yyerror(("Class " + $1->node_name + " not defined").c_str());
				$$->is_error = 1;
			}
			else if (ret == 0){
				yyerror(("Class " + $1->type.substr(6, $1->type.length()-6) + " has no member " + string($3->tempName)).c_str());
				$$->is_error = 1;
			}
			else{
				$$->type = StructAttrType($1->type, temp);
				$$->tempName = $1->tempName + "." + temp;
				
				qid temp_var = newtemp($$->type);
				sym_entry* attr_sym = retTypeAttrEntry($1->type, string($3->tempName), $1->tempName);
				emit(qid("member_access", NULL), $1->place, qid(string($3->tempName), attr_sym), temp_var, -1);
				temp_var.second->array_dims = attr_sym->array_dims;
				$$->place = temp_var;
			}
		}
		else{
			if($1->expType==4){
				yyerror("constant expression cannot be used as lvalue");
			}
			$$->is_error = 1;
		}
    }


//start
CompilationUnit
    : OrdinaryCompilationUnit {
        vector<data2> v;
        insertAttr(v, $1, "", 1);
        $$ = makenode("CompilationUnit",v);
    }
    ;
    
OrdinaryCompilationUnit
    : TopLevelClassOrInterfaceDeclarations {
        $$ = $1;
    }
    ;

TopLevelClassOrInterfaceDeclarations
    : %empty {$$=NULL;}
    |TopLevelClassOrInterfaceDeclarations  TopLevelClassOrInterfaceDeclaration {
        vector<data2> v;
		insertAttr(v,$1,"",1);
		insertAttr(v,$2,"",1);
		$$ = makenode("Top_level_class_or_interface_declarations",v);
		cout << "leaving top level\n";
    }
    ;

TopLevelClassOrInterfaceDeclaration
    : ClassDeclaration { $$ = $1;}
    |';' {
        $$ = makeleaf(";");
    }
    ;

//grammar from classes

ClassDeclaration
    : Modifiers CLASS G S ClassBody {
		vector<data2>v;
        if($1 != NULL) insertAttr(v,$1,"",1);
        insertAttr(v,$3,"",1);
        insertAttr(v,$5,"",1);
        $$ = makenode($2,v);

        // Semantics
		cout << "hiii\n";
		if(!currTypeLookup("class_" + string($3->tempName))){
			cout << "hi\n";
			printStructTable("class_" + string($3->tempName));
			$$->type = "class_" + string($3->tempName);
		}
		else {
			yyerror(("redefinition of class " + string($3->tempName)).c_str());
		}
		type = "";
    }
    | CLASS G S ClassBody {
        vector<data2> v;
        insertAttr(v,$2,"",1);
        insertAttr(v,$4,"",1);
        $$ = makenode($1,v);

        // Semantics
		cout << "hiii\n";
		if(!currTypeLookup("class_" + string($2->tempName))){
			cout << "hi\n";
			printStructTable("class_" + string($2->tempName));
			cout << "hii\n";
			type = string("class_" + string($2->tempName));
			$$->type = type;
		}
		else {
			yyerror(("redefinition of class " + string($2->tempName)).c_str());
			$$->is_error = 1;
		}
		type = "";
    }
    ;

Modifiers
    : Modifier {$$=$1;}
    | Modifier Modifiers {
        vector<data2> v;
        insertAttr(v,$1,"",1);
        insertAttr(v,$2,"",1);
        $$ = makenode("modifier",v);

        //  Semantics
		if($1->is_error || $2->is_error)	{
			$$->is_error = 1;
		}
        else{
            $$->type = string($1->type + "_" + $2->type);
        }
    }
    ;

Modifier
    :PUBLIC{
        $$=makeleaf($1);
        $$->type = "public";
    }
    |PRIVATE{
        $$=makeleaf($1);
        $$->type = "private";
    }
    |STATIC{
        $$=makeleaf($1);
        $$->type = "static";
    }
    |FINAL{
        $$=makeleaf($1);
        $$->type = "final";
    }
    ;

ClassBody
    : '{' ClassBodyDeclarations '}' {
		vector<data2> v;
		cout<<"entered Class body"<<endl;
        insertAttr(v,NULL,"{",0);
        if($2 != NULL) insertAttr(v,$2,"",1);
        insertAttr(v,NULL,"}",0);
        $$ = makenode("classBody",v);
		cout << "leaving class body\n";
    }
    ;

ClassBodyDeclarations
    : %empty {$$=NULL;}
    | ClassBodyDeclarations ClassBodyDeclaration{
        vector<data2> v;
        insertAttr(v,$1,"",1);
        insertAttr(v,$2,"",1);
        $$ = makenode("Class_Body_Declarations",v);

        // Semantics
		cout << "in classbodydeclarations\n";
    }
    ;

ClassBodyDeclaration
    : FieldDeclaration {$$=$1;}
    | MethodDeclaration {$$=$1;}
    | StaticInitializer {$$=$1;}
    | ConstructorDeclaration {$$=$1;}
    ;

FieldDeclaration
    : Modifiers PrimitiveType VariableDeclaratorList ';' {
        vector<data2> v;
        insertAttr(v,$1,"",1);
        insertAttr(v,$2,"",1);
        insertAttr(v,$3,"",1);
        insertAttr(v,NULL,";",0);
        $$ = makenode("Field_Declaration",v);

        // Semantics
		type = $2->type ;
		className = classTemp;
		type_delim = 0;

    }
    | PrimitiveType VariableDeclaratorList ';' {
        vector<data2> v;
        insertAttr(v,$1,"",1);
        insertAttr(v,$2,"",1);
        insertAttr(v,NULL,";",0);
        $$ = makenode("Field_Declaration",v);

        // Semantics
        type = $1->type ;
		className = classTemp;
		type_delim = 0;
    }
    ;


VariableDeclaratorList
    : VariableDeclarator {
        $$ = $1;
    }
    | VariableDeclaratorList ',' VariableDeclarator {
        vector<data2> v;
        insertAttr(v,$1,"",1);
        insertAttr(v,NULL,",",0);
        insertAttr(v,$3,"",1);
        $$ = makenode("Variable_Declarator_List",v);
    }
    ;

VariableDeclarator
    : Declarator {
        $$ = $1;

		// Semantics
		if (insertStructAttr($1->tempName, $1->type, $1->size, 0) != 1){
			yyerror(("The Attribute " + string($1->tempName) + " is already declared in the same class").c_str());
		} 
		cout << "in Variable declarator\n";
    }
    | Declarator '=' VariableInitializer {

        vector<data2>v;
        insertAttr(v,$1,"",1);
        insertAttr(v,$3,"",1);
        $$=makenode("=",v);

        // Semantics
        if(assignExp($1->type,$3->type,"=") == ""){
			cout<<$3->type<<endl;
            yyerror("Incorrect type assignment");
        }
		if (insertStructAttr($1->tempName, $1->type, $1->size, 1) != 1){
			yyerror(("The Attribute " + string($1->tempName) + " is already declared in the same class").c_str());
		} 
		//3 AC
		$$->type=$1->type;
		$1->place = qid($1->tempName, lookup($1->tempName));
		int num = assign_exp($2, $$->type, $1->type, $3->type, $1->place, $3->place);
		$$->place = $1->place;
		backpatch($3->nextlist, num);
    }
    ;

Declarator
    : Identifier {
        $$ = makeleaf($1);

		// Semantics
        type_delim = 1;
		$$->expType = 1; // Variable
		if(type != "") $$->type = type;
		else {
            yyerror("Unspecified type of the identifier\n");
        }
		$$->tempName = string($1);
		$$->size = getSize(type);

		//3AC
		
    }
    | Declarator '[' ']' {
        vector<data2> v;
		insertAttr(v, $1, "", 1);
		insertAttr(v, NULL, "[ ]", 0);
		$$ = makenode("direct_declarator", v);

		// Semantics
		if($1->expType <=2 ) {
			$$->expType = 2;
			$$->type = $1->type + "*";
			$$->tempName = $1->tempName;
			$$->size = 4;	
			$$->intVal = 8;

			//3AC
			$$->place = qid($$->tempName, NULL);
			array_dims.push_back(0);
		}
		else yyerror(( $1->tempName + " declared as function returning an array").c_str());
    }
    ;

MethodDeclaration
    :MethodHeader MethodBody {
        vector<data2> v;
        insertAttr(v,$1,"",1);
        insertAttr(v,$2,"",1);
        $$ = makenode("Method_declaration",v);

        // Semantics
		for(auto i: gotolablelist){
			if(gotolabel.find(i.first) == gotolabel.end()){
				yyerror(("label \'" + string(i.first) + "\' used but not defined").c_str());
			}
			else backpatch(i.second, gotolabel[i.first]);
		}
		emit(qid("FUNC_"+className+ "."+funcName + " end :", NULL), qid("",NULL), qid("", NULL), qid("", NULL), -1);
		backpatch_rem();
    }
    ;
MethodHeader
    :Modifiers PrimitiveType MethodorConstrDeclarator{
        vector<data2> v;
        insertAttr(v,$1,"",1);
        insertAttr(v,$2,"",1);
        insertAttr(v,$3,"",1);
        $$ = makenode("Method_Header",v);

        // Semantics
		type = $2->type ;
		type_delim = 0;

		//3AC
		emit(qid("push",NULL),qid("",NULL),qid("",NULL),qid("BP",NULL),-1);
		emit(qid("=",NULL),qid("SP",NULL),qid("",NULL),qid("BP",NULL),-1);
		for(auto it:par){
			sym_entry* n = lookup(it);
			if(n){
				int offset=n->offset;
				emit(qid("=",NULL),qid("[BP"+ to_string(offset) +"]",NULL),qid("",NULL),qid(it,NULL),-1);
			}
		}
		par.clear();
    }
    |PrimitiveType MethodorConstrDeclarator{
        vector<data2> v;
        insertAttr(v,$1,"",1);
        insertAttr(v,$2,"",1);
        $$ = makenode("Method_Header",v);

        // Semantics
		type = $1->type;
		// funcName = funcTemp;
		type_delim = 0;

		//3AC
		emit(qid("push",NULL),qid("",NULL),qid("",NULL),qid("BP",NULL),-1);
		emit(qid("=",NULL),qid("SP",NULL),qid("",NULL),qid("BP",NULL),-1);
		for(auto it:par){
			sym_entry* n = lookup(it);
			if(n){
				int offset=n->offset;
				emit(qid("=",NULL),qid("[BP"+ to_string(offset) +"]",NULL),qid("",NULL),qid(it,NULL),-1);
			}
		}
		par.clear();
    }
    |Modifiers VOID2 MethodorConstrDeclarator{
        vector<data2> v;
        insertAttr(v,$1,"",1);
        insertAttr(v,$2,"",1);
        insertAttr(v,$3,"",1);
        $$ = makenode("Method_Header",v);

        // Semantics
		type = "void";
		className = classTemp;
		type_delim = 0;

		//3AC
		emit(qid("push",NULL),qid("",NULL),qid("",NULL),qid("bp",NULL),-1);
		emit(qid("=",NULL),qid("sp",NULL),qid("",NULL),qid("bp",NULL),-1);
		for(auto it:par){
			sym_entry* n = lookup(it);
			if(n){
				int offset=n->offset;
				emit(qid("=",NULL),qid("[BP"+ to_string(offset)+"]",NULL),qid("",NULL),qid(it,NULL),-1);
			}
		}
		par.clear();
    }
    |VOID2 MethodorConstrDeclarator{
        vector<data2> v;
        insertAttr(v,$1,"",1);
        insertAttr(v,$2,"",1);
        $$ = makenode("Method_Header",v);

        // Semantics
		type = "void";
		className = classTemp;
		type_delim = 0;

		//3AC
		emit(qid("push",NULL),qid("",NULL),qid("",NULL),qid("bp",NULL),-1);
		emit(qid("=",NULL),qid("sp",NULL),qid("",NULL),qid("bp",NULL),-1);
		for(auto it:par){
			sym_entry* n = lookup(it);
			if(n){
				int offset=n->offset;
				emit(qid("=",NULL),qid("[BP"+ to_string(offset)+ "]",NULL),qid("",NULL),qid(it,NULL),-1);
			}
		}
		par.clear();
    }
    ;

VOID2  
    : VOID {
        $$ = makeleaf($1);

        // Semantics
		if(type == "") type = string($1);
		else if(!type_delim) type += " " + string($1);
		$$->type = $1;
    }
    ;

MethodorConstrDeclarator
    : SimpleName2 '(' A FormalParameterList ')' NEXT_QUAD {
        vector<data2> v;
        insertAttr(v,$1,"",1);
        insertAttr(v,NULL,"(",0);
        insertAttr(v,$4,"",1);
        insertAttr(v,NULL,")",0);
        $$ = makenode("Method_declarator",v);

		// Semantics
			if($1->expType == 1) {
				$$->tempName = $1->tempName;
				$$->expType = 3;
				$$->type = string($1->type);
				$$->size = getSize($$->type);

				vector<string> temp = getFuncArgs($1->tempName);
				if(temp.size() >=1 && temp[0] == "#NO_FUNC"){
					insertFuncArg($$->tempName, funcArgs, $$->type);
					// for(auto it:temp)cout<<it<<endl;
					funcArgs.clear();
					funcName = string($1->tempName);
					funcType = $1->type;

					//3AC
					$$->place = qid($$->tempName, NULL);
					backpatch($4->nextlist,$6);
					{emit(pair<string,sym_entry*>("FUNC_"+className+ "." + $1->tempName +" start :",NULL),pair<string,sym_entry*>("",NULL),pair<string,sym_entry*>("",NULL),pair<string,sym_entry*>("",NULL),-2);}
					
				}
				else{
					// Check if temp is correct
					if(temp == funcArgs){
						funcArgs.clear();
						funcName = string($1->tempName);
						funcType = $1->type;

						//3AC
						$$->place = qid($$->tempName, NULL);
						backpatch($4->nextlist,$6);
						{emit(pair<string,sym_entry*>("FUNC_" +className+ "."+ $1->tempName + " start :",NULL) ,pair<string,sym_entry*>("",NULL),pair<string,sym_entry*>("",NULL),pair<string,sym_entry*>("",NULL),-2);}
					}
					else {
						yyerror(("Conflicting types for function " + $1->tempName).c_str());
					}
				}
			}
			else {
				if($1->expType == 2){
					yyerror( ($1->tempName + "declared as array of function").c_str());
				}
				else{
					yyerror( ($1->tempName + "declared as function of function").c_str());
				}
			}
	}
	| SimpleName2 '(' A ')' Dimsy {
		vector<data2> v;
		insertAttr(v, $1, "", 1);
		insertAttr(v, NULL, "( )", 0);
        if($5 != NULL) insertAttr(v,$5,"",1);
		$$ = makenode("direct_declarator", v);

		// Semantics
			if($1->expType == 1) {
				$$->tempName = $1->tempName;
				$$->expType = 3;
				$$->type = "FUNC_" + string($1->type);
				$$->size = getSize($$->type);

				vector<string> temp = getFuncArgs($1->tempName);
				if((temp.size() == 1 && temp[0] == "#NO_FUNC") || funcArgs == temp){
					insertFuncArg($$->tempName, funcArgs, $$->type);
					funcArgs.clear();
					funcName = string($1->tempName);
					funcType = $1->type;
				}
				else {
					yyerror(("Conflicting types for function " + $1->tempName).c_str());
				}
				//3AC
				$$->place = qid($$->tempName, NULL);
				emit(pair<string,sym_entry*>("FUNC_" + className+ "."+$$->tempName +" start :",NULL),pair<string,sym_entry*>("",NULL),pair<string,sym_entry*>("",NULL),pair<string,sym_entry*>("",NULL),-2);
			}
			else {
				if($1->expType == 2){
					yyerror( ($1->tempName + "declared as array of function").c_str());
				}
				else{
					yyerror( ($1->tempName + "declared as function of function").c_str());
				}
			}
	}
    ;

SimpleName2
    : Identifier {
        $$ = makeleaf($1);

        // Semantics
        type_delim = 1;
		$$->expType = 1; // Variable
		if(type != "") $$->type = type;
		else {
            yyerror("Undeclared Type\n");
        }
		$$->tempName = string($1);
		$$->size = getSize(type);

		//3AC
		$$->place = qid($$->tempName, NULL);
    }
    ;

VariableInitializer
    : Expression {$$=$1;}
    ;

Dimsy
    : %empty {$$=NULL;}
    | Dims {$$=$1;}
    ;

FormalParameterList
    : FormalParameter {
        $$ = $1;
		par.push_back($1->tempName);
    }
    | FormalParameterList ',' NEXT_QUAD FormalParameter {
        vector<data2> v;
        insertAttr(v,$1,"",1);
        insertAttr(v,NULL,",",0);
        insertAttr(v,$4,"",1);
        $$ = makenode("Formal_Parameter_list",v);

        // Semantics
        // 3AC
		par.push_back($4->tempName);
		backpatch($1->nextlist, $3);
		$$->nextlist = $4->nextlist;
    }
    ;


FormalParameter
    : PrimitiveType SimpleName2 Dimsy {
        vector<data2> v;
        insertAttr(v,$1,"",1);
        insertAttr(v,$2,"",1);
        insertAttr(v,$3,"",1);
        $$ = makenode("Formal_Parameter",v);

        // Semantics
        if($3 != NULL){
            $2->type = string($2->type + $3->type );
            $2->expType = 2;
        }
		type_delim = 0;
		type = "";
		$$->tempName=$2->tempName;
		if($2->expType == 1 || $2->expType == 2) {
			paramInsert(*curr_table, $2->tempName, $2->type, $2->size, 1, NULL);
			funcArgs.push_back($2->type);
		}
		else {
			yyerror("Argument type is not variable or array");
		}
    }
    ;


MethodBody
    : Block {$$=$1;}
    | ';' {
		$$=makeleaf(";");
		// if(func_flag>=2){
			int bc = block_stack.top();
			block_stack.pop();
			string str = "Block" + to_string(bc);
			string name = funcName+str+".csv";
			printSymbolTable(curr_table, name);
			updSymbolTable(str,0);
		// 	func_flag--;
		// }
	}
    ;

StaticInitializer
    : STATIC Block {
        vector<data2> v;
        insertAttr(v,makeleaf($1),"",1);
        insertAttr(v,$2,"",1);
        $$ = makenode("StaticInitilizer",v);

        $$->is_error = $2->is_error;
    }
    ;

ConstructorDeclaration
    : Modifiers MethodorConstrDeclarator ConstructorBody {
        vector<data2> v;
        insertAttr(v,$1,"",1);
        insertAttr(v,$2,"",1);
        insertAttr(v,$3,"",1);
        $$ = makenode("Constructor_declaration",v);

        // Semantics
		type = "";
		className = classTemp;
		type_delim = 0;
		$$->is_error = $1->is_error || $2->is_error || $3->is_error;
    }
    ;

ConstructorBody
    : '{' ExplicitConstructorInvocation BlockStatements '}' {
        vector<data2> v;
        insertAttr(v,NULL,"{",0);
        insertAttr(v,$2,"",1);
        insertAttr(v,$3,"",1);
        insertAttr(v,NULL,"}",0);
        $$ = makenode("Constructor_body",v);
    }
    | '{' BlockStatements '}' {
        vector<data2> v;
        insertAttr(v,NULL,"{",0);
        insertAttr(v,$2,"",1);
        insertAttr(v,NULL,"}",0);
        $$ = makenode("Constructor_body",v);
    }
    ;

ExplicitConstructorInvocation
    : THIS '(' ArgumentListy ')' ';' {
        vector<data2> v;
        insertAttr(v,makeleaf($1),"",1);
        insertAttr(v,NULL,"(",0);
        insertAttr(v,$3,"",1);
        insertAttr(v,NULL,")",0);
        insertAttr(v,NULL,";",0);
        $$ = makenode("ExplicitConstructorInvocation",v);


    }
    ;

ArgumentListy
    : %empty {$$=NULL;}
    | ArgumentList {$$=$1;}
    ;
    
ClassBodyy
    : %empty {$$=NULL;}
    | ClassBody {$$=$1;}
    ;

//10. Arrays



//14. Productions from (blocks, statements and patterns)

Block
    :'{' ChangeTable BlockStatements '}'{
        $$ =$3;
        cout << "in Block\n";
        // if(func_flag>=2){
			int bc = block_stack.top();
			block_stack.pop();
			string str = "Block" + to_string(bc);
			string name = funcName+str+".csv";
			printSymbolTable(curr_table, name);
			updSymbolTable(str,0);
		// 	func_flag--;
		// }
    }
    |'{' ChangeTable '}'{
        $$ =NULL;
        cout << "in Block\n";
        // if(func_flag>=2){
			int bc = block_stack.top();
			block_stack.pop();
			string str = "Block" + to_string(bc);
			string name = funcName+str+".csv";
			printSymbolTable(curr_table, name);
			updSymbolTable(str,0);
		// 	func_flag--;
		// }
    }
    ;

BlockStatements
    : BlockStatement {$$=$1;}
    | BlockStatements NEXT_QUAD BlockStatement {
		cout << "in Block statements\n";
        vector<data2>v;
        if($1 != NULL) insertAttr(v, $1, "", 1);
        insertAttr(v, $3, "", 1);
		$$ = makenode("BlockStatements", v);

        backpatch($1->nextlist, $2);
        $$->nextlist = $3->nextlist;
		$1->caselist.insert($1->caselist.end(), $3->caselist.begin(), $3->caselist.end());
        $$->caselist = $1->caselist;
		$1->continuelist.insert($1->continuelist.end(), $3->continuelist.begin(), $3->continuelist.end());
		$1->breaklist.insert($1->breaklist.end(), $3->breaklist.begin(), $3->breaklist.end());
        $$->continuelist = $1->continuelist;
        $$->breaklist = $1->breaklist;
		cout << "in Block statements2\n";
    }
    ;

BlockStatement
    :Declaration_list {$$=$1;}
    |Statement {$$=$1;} 
    ;

Declaration_list
    : LocalVariableDeclaration ';' {$$=$1;}
    | ClassDeclaration {$$=$1;}
    ;

LocalVariableDeclaration
    :PrimitiveType VariableDeclaratorList{
        vector<data2>v;
        insertAttr(v, $1, "", 1);
        insertAttr(v, $2, "", 1);
		$$ = makenode("LocalVariableDeclaration", v);

        // Semantics
		cout << "in local variable declaration\n";
		type = $1->type ;
		type_delim = 0;

		//3ac
    }
    ;


Statement
    :StatementWithoutTrailingSubstatement{$$=$1;}
    |LabeledStatement{$$=$1;}
    |IfThenStatement{$$=$1;}
    |IfThenElseStatement{$$=$1;}
    |WhileStatement{$$=$1;}
    |ForStatement{$$=$1;}
    ;

StatementNoShortIf
    :StatementWithoutTrailingSubstatement{$$=$1;}
    |LabeledStatementNoShortIf{$$=$1;}
    |IfThenElseStatementNoShortIf{$$=$1;}
    |WhileStatementNoShortIf{$$=$1;}
    |ForStatementNoShortIf{$$=$1;}
    ;

StatementWithoutTrailingSubstatement
    :Block{$$=$1;}
    |';'{$$=makeleaf(";");}
    |ExpressionStatement{$$=$1;}
    |BreakStatement{$$=$1;}
    |ContinueStatement{$$=$1;}
    |ReturnStatement{$$=$1;}
    |ThrowStatement{$$=$1;}
    ;   

LabeledStatement
    : SimpleName ':' NEXT_QUAD Statement{
        vector<data2>v;
        insertAttr(v, $1, "", 1);
        insertAttr(v, NULL, ":", 0);
        insertAttr(v,$4, "", 1);
		$$ = makenode("LabeledStatement", v);


        //semantic
        if($4->is_error)	{
			$$->is_error = 1;
		}

		if(gotolabel.find($1->tempName) != gotolabel.end()){
			yyerror(string("duplicate label \'" + string($1->tempName) + "\'").c_str());
			$$->is_error = 1;
		}
		else{
			gotolabel.insert({string($1->tempName), $3});
		}
		$$->nextlist = $4->nextlist;
		$$->caselist = $4->caselist;
		$$->continuelist = $4->continuelist;
		$$->breaklist = $4->breaklist;

    }
;

LabeledStatementNoShortIf
    :SimpleName ':' NEXT_QUAD StatementNoShortIf{
        vector<data2>v;
        insertAttr(v, $1, "", 1);
        insertAttr(v, NULL, ":", 0);
        insertAttr(v,$4, "", 1);
		$$ = makenode("LabeledStatementNoShortIf", v);

		//semantic
		if($4->is_error)	{
			$$->is_error = 1;
		}

		if(gotolabel.find($1->tempName) != gotolabel.end()){
			yyerror(string("duplicate label \'" + string($1->tempName) + "\'").c_str());
			$$->is_error = 1;
		}
		else{
			gotolabel.insert({string($1->tempName), $3});
		}
		$$->nextlist = $4->nextlist;
		$$->caselist = $4->caselist;
		$$->continuelist = $4->continuelist;
		$$->breaklist = $4->breaklist;

    }
;

ExpressionStatement
    :StatementExpression ';'{
		$$ = $1;
    }
;

StatementExpression
    :Assignment{$$=$1;}
    |PreIncrementExpression{$$=$1;}
    |PreDecrementExpression{$$=$1;}
    |PostIncrementExpression{$$=$1;}
    |PostDecrementExpression{$$=$1;}
    |MethodInvocation{$$=$1;}
    |ClassInstanceCreationExpression{$$=$1;}
;

IF_CODE
    : IF {if_found = 1;} '(' Expression ')' {
        if($4->truelist.empty() && $4->falselist.empty()) {
            int a = code.size();
			backpatch($4->nextlist, a);
            emit(qid("GOTO", NULL),qid("IF", lookup("if")), $4->place, qid("", NULL ),0);
            int b = code.size();
            emit(qid("GOTO", NULL),qid("", NULL), qid("", NULL), qid("", NULL ),0);
            $4->truelist.push_back(a);
            $4->falselist.push_back(b);
        }
        $$ = $4;
		if_found = 0;
    }

IfThenStatement
    :IF_CODE NEXT_QUAD Statement{
        vector<data2> v;
		insertAttr(v, $1, "", 1);
		insertAttr(v, $3, "", 1);
		$$ = makenode("if", v);

        // Semantics
		if($1->is_error || $3->is_error)	{
			$$->is_error = 1;
		}

        // 3AC
        backpatch($1->truelist, $2);
		$3->nextlist.insert($3->nextlist.end(), $1->falselist.begin(), $1->falselist.end());
        $$->nextlist= $3->nextlist;
        $$->continuelist = $3->continuelist;
        $$->breaklist = $3->breaklist;
    }
;

IfThenElseStatement
    :IF_CODE NEXT_QUAD StatementNoShortIf N ELSE NEXT_QUAD Statement{
        vector<data2> v;
		insertAttr(v, $1, "", 1);
		insertAttr(v, $3, "", 1);
		insertAttr(v, $7, "", 1);
		$$ = makenode("if-else", v);

		if($1->is_error || $3->is_error || $7->is_error)	{
			$$->is_error = 1;
		}

        backpatch($1->truelist, $2);
        backpatch($1->falselist, $6);
		$3->nextlist.insert($3->nextlist.end(), $4->nextlist.begin(), $4->nextlist.end());
		$3->nextlist.insert($3->nextlist.end(), $7->nextlist.begin(), $7->nextlist.end());
        $$->nextlist = $3->nextlist;
		$3->breaklist.insert($3->breaklist.end(), $7->breaklist.begin(), $7->breaklist.end());
		$$->breaklist = $3->breaklist;
		$3->continuelist.insert($3->continuelist.end(), $7->continuelist.begin(), $7->continuelist.end());
		$$->continuelist = $3->continuelist;
    }
;

IfThenElseStatementNoShortIf
    :IF_CODE NEXT_QUAD StatementNoShortIf N ELSE NEXT_QUAD StatementNoShortIf {
        vector<data2> v;
		insertAttr(v, $1, "", 1);
		insertAttr(v, $3, "", 1);
		insertAttr(v, $7, "", 1);
		$$ = makenode("if-else", v);

		if($1->is_error || $3->is_error || $7->is_error)	{
			$$->is_error = 1;
		}

        backpatch($1->truelist, $2);
        backpatch($1->falselist, $6);
		$3->nextlist.insert($3->nextlist.end(), $4->nextlist.begin(), $4->nextlist.end());
		$3->nextlist.insert($3->nextlist.end(), $7->nextlist.begin(), $7->nextlist.end());
        $$->nextlist = $3->nextlist;
		$3->breaklist.insert($3->breaklist.end(), $7->breaklist.begin(), $7->breaklist.end());
		$$->breaklist = $3->breaklist;
		$3->continuelist.insert($3->continuelist.end(), $7->continuelist.begin(), $7->continuelist.end());
		$$->continuelist = $3->continuelist;
    }
;

WhileStatement
    : WHILE '(' NEXT_QUAD EXPR_CODE ')' NEXT_QUAD Statement{
        vector<data2> v;
		insertAttr(v, $4, "", 1);
		insertAttr(v, $7, "", 1);
		$$ = makenode("while-loop", v);

        // Semantics
		if($4->is_error || $7->is_error)	{
			$$->is_error = 1;
		}
	
        // 3AC
        backpatch($4->truelist, $6);
		$7->nextlist.insert($7->nextlist.end(), $7->continuelist.begin(), $7->continuelist.end());
        backpatch($7->nextlist, $3);
        $$->nextlist = $4->falselist;
        $$->nextlist.insert($$->nextlist.end(), $7->breaklist.begin(), $7->breaklist.end());
        emit(qid("GOTO", NULL), qid("", NULL), qid("", NULL), qid("", NULL), $3);
    }
;

WhileStatementNoShortIf
    : WHILE '(' NEXT_QUAD EXPR_CODE ')' NEXT_QUAD StatementNoShortIf {
        vector<data2> v;
		insertAttr(v, $4, "", 1);
		insertAttr(v, $7, "", 1);
		$$ = makenode("while-loop", v);

        // Semantics
		if($4->is_error || $7->is_error)	{
			$$->is_error = 1;
		}
	
        // 3AC
        backpatch($4->truelist, $6);
		$7->nextlist.insert($7->nextlist.end(), $7->continuelist.begin(), $7->continuelist.end());
        backpatch($7->nextlist, $3);
        $$->nextlist = $4->falselist;
        $$->nextlist.insert($$->nextlist.end(), $7->breaklist.begin(), $7->breaklist.end());
        emit(qid("GOTO", NULL), qid("", NULL), qid("", NULL), qid("", NULL), $3);
    }
;

ForStatement
    : BasicForHeader Statement{
        vector<data2> v;
        insertAttr(v,$1, "", 1);
        insertAttr(v,$2, "", 1);
		$$ = makenode("For_statement", v);

         //semantic 

        if($1->is_error || $2->is_error)	{
			$$->is_error = 1;
		}

        //3ac
    }
    | EnhancedForHeader Statement{
        vector<data2> v;
        insertAttr(v,$1, "", 1);
        insertAttr(v,$2, "", 1);
		$$ = makenode("For_statement", v);

         //semantic 

        if($1->is_error || $2->is_error)	{
			$$->is_error = 1;
		}

        //3ac
    }
;

ForStatementNoShortIf
    : BasicForHeader StatementNoShortIf{
        vector<data2> v;
        insertAttr(v,$1, "", 1);
        insertAttr(v,$2, "", 1);
		$$ = makenode("For_statement_no_short_if", v);

        //semantic 

        if($1->is_error || $2->is_error)	{
			$$->is_error = 1;
		}

        //3ac

    }
    | EnhancedForHeader StatementNoShortIf{
        vector<data2> v;
        insertAttr(v,$1, "", 1);
        insertAttr(v,$2, "", 1);
		$$ = makenode("For_statement_no_short_if", v);

        //semantic 

        if($1->is_error || $2->is_error) {
			$$->is_error = 1;
		}

        //3ac
    }
;

BasicForHeader
    : FOR '(' ForInity ';' Expressiony ';' ForUpdatey ')' {
        vector<data2>v;
        insertAttr(v, makeleaf($1), "", 1);
        insertAttr(v, NULL, "(", 0);
        insertAttr(v,$3, "", 1);
        insertAttr(v, NULL, ";", 0);
        insertAttr(v,$5, "", 1);
        insertAttr(v, NULL, ";", 0);
        insertAttr(v,$7, "", 1);
        insertAttr(v, NULL, ")", 0);
		$$ = makenode("Basic_For_Header", v);

        //semantic 

        //3ac

    }

EnhancedForHeader
    : FOR '(' LocalVariableDeclaration ':' Expression ')' {
        vector<data2>v;
        insertAttr(v, makeleaf($1), "", 1);
        insertAttr(v, NULL, "(", 0);
        insertAttr(v,$3, "", 1);
        insertAttr(v, NULL, ":", 0);
        insertAttr(v,$5, "", 1);
        insertAttr(v, NULL, ")", 0);
		$$ = makenode("Enhanced_For_Header", v);

        //semantic 

        if($3->is_error || $5->is_error)	{
			$$->is_error = 1;
		}

        //3ac
    }

ForInity
    : %empty {$$=NULL;}
    | ForInit {$$=$1;}
    ;

Expressiony
    : %empty {$$=NULL;}
    | Expression {$$=$1;}
    ;

ForUpdatey
    : %empty {$$=NULL;}
    | ForUpdate {$$=$1;}
    ;

ForInit
    :StatementExpressionList{$$=$1;}
    |LocalVariableDeclaration{$$=$1;}
;

ForUpdate
    :StatementExpressionList{$$=$1;}
;

StatementExpressionList
    :StatementExpression{
		$$ = $1;
    }
    |StatementExpression ',' StatementExpressionList{
        vector<data2>v;
        insertAttr(v,$1, "", 1);
        insertAttr(v, NULL, ",", 0);
        insertAttr(v,$3,"",1);
		$$ = makenode("StatementExpressionList2", v);
    }
;


BreakStatement
    :BREAK SimpleName ';'{
        vector<data2>v;
        insertAttr(v, makeleaf($1), "", 1);
        insertAttr(v,$2, "", 1);
        insertAttr(v, NULL, ";", 0);
		$$ = makenode("BreakStatement", v);

        int a = code.size();
        emit(qid("GOTO", NULL), qid("", NULL), qid("", NULL), qid("", NULL), 0);
        $$->breaklist.push_back(a);
    }
    |BREAK ';'{
        $$ = makeleaf($1);
        
        int a = code.size();
        emit(qid("GOTO", NULL), qid("", NULL), qid("", NULL), qid("", NULL), 0);
        $$->breaklist.push_back(a);
    }
;

ContinueStatement
    :CONTINUE SimpleName ';'{
        vector<data2>v;
        insertAttr(v, makeleaf($1), "", 1);
        insertAttr(v,$2, "", 1);
        insertAttr(v, NULL, ";", 0);
		$$ = makenode("ContinueStatement", v);

        // Semantics
        int a = code.size();
        emit(qid("GOTO", NULL), qid("", NULL), qid("", NULL), qid("", NULL), 0);
        $$->continuelist.push_back(a);
    }
    |CONTINUE ';'{
        vector<data2>v;
        insertAttr(v, makeleaf($1), "", 1);
        insertAttr(v, NULL, ";", 0);
		$$ = makenode("ContinueStatement", v);

        // Semantics
        int a = code.size();
        emit(qid("GOTO", NULL), qid("", NULL), qid("", NULL), qid("", NULL), 0);
        $$->continuelist.push_back(a);
    }
;

ReturnStatement
    :RETURN Expression ';'{
        vector<data2>v;
        insertAttr(v, makeleaf($1), "", 1);
        insertAttr(v,$2, "", 1);
        insertAttr(v, NULL, ";", 0);
		$$ = makenode("ReturnStatement", v);

        // Semantics

		backpatch($2->nextlist,code.size());
        emit(qid("POP", NULL), qid("BP",NULL), qid("", NULL), qid("", NULL), -1);
        emit(qid("RETURN", NULL), $2->place, qid("", NULL), qid("", NULL), -1);
    }
    | RETURN ';' {
        $$ = makeleaf($1);

        // Semantics
		emit(qid("POP", NULL), qid("BP",NULL), qid("", NULL), qid("", NULL), -1);
        emit(qid("RETURN", NULL), qid("", NULL), qid("", NULL), qid("", NULL), -1);
    }
;

ThrowStatement
    :THROW Expression ';'{
        vector<data2>v;
        insertAttr(v, makeleaf($1), "", 1);
        insertAttr(v,$2, "", 1);
        insertAttr(v, NULL, ";", 0);
		$$ = makenode("ThrowStatement", v);

        // Semantics
        yyerror("Not implemented yet\n");        
    }
;


EXPR_CODE
    : {if_found = 1;} StatementExpression {
        if($2->truelist.empty() && $2->falselist.empty()) {
            int a = code.size();
			backpatch($2->nextlist, a);
            emit(qid("GOTO", NULL),qid("IF", lookup("if")), $2->place, qid("", NULL ),0);
            int b = code.size();
            emit(qid("GOTO", NULL),qid("", NULL), qid("", NULL), qid("", NULL ),0);
            $2->truelist.push_back(a);
            $2->falselist.push_back(b);
        }
        $$ = $2;
		if_found = 0;
    }
    ;

N
    : %empty {
        int a = code.size();
		$$ = new treeNode;
        emit(qid("GOTO", NULL), qid("", NULL), qid("", NULL), qid("", NULL), 0);
        $$->nextlist.push_back(a);
    }
    ;

//Grammar for Expressions

Primary
    :PrimaryNoNewArray{$$=$1;}
    |ArrayCreationExpression{$$ = $1;}
    ;
PrimaryNoNewArray
    :Literal{
		$$=$1;
		$$->isInit=1;
		}
    |THIS {$$ = makeleaf($1);}
    |'(' Expression ')'{$$=$2;}
    |ClassInstanceCreationExpression{$$=$1;}
    |ArrayAccess {$$ = $1;}
    |MethodInvocation {$$ = $1;}
    ;


ClassInstanceCreationExpression
    :UnqualifiedClassInstanceCreationExpression {$$ = $1;}
    |Name '.' UnqualifiedClassInstanceCreationExpression{
        vector<data2>v;
        insertAttr(v,$1, "", 1);
        insertAttr(v, NULL, ".", 0);
        insertAttr(v,$3, "", 1);
		$$ = makenode("ClassInstanceCreationExpression", v);
    }
    |Primary '.' UnqualifiedClassInstanceCreationExpression{
        vector<data2>v;
        insertAttr(v,$1, "", 1);
        insertAttr(v, NULL, ".", 0);
        insertAttr(v,$3, "", 1);
		$$ = makenode("ClassInstanceCreationExpression", v);
    }
    ;

UnqualifiedClassInstanceCreationExpression
    :NEW ClassOrInterfaceTypeToInstantiate '(' ArgumentListy ')' ClassBodyy {
        vector<data2>v;
        insertAttr(v, makeleaf($1), "", 1);
        insertAttr(v, $2, "", 1);
        insertAttr(v, NULL, "(", 1);
        insertAttr(v, $4, "", 1);
        insertAttr(v, NULL, ")", 1);
        insertAttr(v, $6, "", 1);
		$$ = makenode("UnqualifiedClassInstanceCreationExpression", v);
    }
    ;

ClassOrInterfaceTypeToInstantiate
    : SimpleName ClassOrInterfaceTypeToInstant TypeArgumentsOrDiamondy {
        vector<data2>v;
        insertAttr(v,$1, "", 1);
        insertAttr(v,$2, "", 1);
        insertAttr(v,$3, "", 1);
		$$ = makenode("ClassOrInterfaceTypeToInstantiate", v);
    }
    ;

TypeArgumentsOrDiamondy
    : %empty {$$=NULL;}
    | TypeArgumentsOrDiamond {$$=$1;}
    ;

ClassOrInterfaceTypeToInstant
    : %empty {$$=NULL;}
    | '.' SimpleName ClassOrInterfaceTypeToInstant  {
        vector<data2>v;
        insertAttr(v,NULL,".",0);
        insertAttr(v, $2, "", 1);
        insertAttr(v,$3, "", 1);
		$$ = makenode("ClassOrInterfaceTypeToInstant", v);
    }
    ;

TypeArgumentsOrDiamond
    :'<''>'{
        vector<data2>v;
        insertAttr(v, NULL, "<", 0);
        insertAttr(v, NULL, ">", 0);
		$$ = makenode("TypeArgumentsOrDiamond", v);
    }
    ;

ArrayAccess
    :Name '[' Expression ']' {
        vector<data2>v;
        insertAttr(v,$1, "", 1);
        insertAttr(v, NULL, "[", 0);
        insertAttr(v,$3, "", 1);
        insertAttr(v, NULL, "]", 0);
		$$ = makenode("ArrayAccess", v);

		// Semantics
		if($1->expType == 2){
			string tmp = $1->type;
			$$->type = tmp.substr(0,tmp.length()-1);
			if(($$->type)[tmp.length()-2]=='*') $$->expType = 2;
			else $$->expType = 1;
		}
		yyerror("Accessing field of a non-array construct");
    }
    |ArrayAccess '[' Expression ']'{
        vector<data2>v;
        insertAttr(v,$1, "", 1);
        insertAttr(v, NULL, "[", 0);
        insertAttr(v,$3, "", 1);
        insertAttr(v, NULL, "]", 0);
		$$ = makenode("ArrayAccess", v);
		// Semantics
		if($1->expType == 2){
			string tmp = $1->type;
			$$->type = tmp.substr(0,tmp.length()-1);
			if(($$->type)[tmp.length()-2]=='*') $$->expType = 2;
			else $$->expType = 1;
		}
		yyerror("Accessing field of a non-array construct");
    }

    ;

MethodInvocation
    :Name '(' { sym_entry* n = lookup($1->tempName);
				if(n){
					int size=n->size;
					emit(qid("-int",NULL),qid("SP",NULL),qid(to_string(size),NULL),qid("SP",NULL),-1);
				}
				currArgs.push_back(vector<string>()); } ArgumentListy ')' {
        vector<data2>v;
        insertAttr(v, $1, "", 1);
        insertAttr(v, NULL, "(", 0);
        insertAttr(v,$4, "", 1);
        insertAttr(v, NULL, ")", 0);
		$$ = makenode("MethodInvocation", v);
		//semantics
		string temp = postfixExpression($1->type,3);
		if(temp.empty()){
			temp = getFuncType($1->tempName);
		}
		if(!temp.empty()){	
			$$->type = temp;
			if($1->expType ==3){
				vector<string> funcArgs = getFuncArgs($1->tempName);
				vector<string> tempArgs =currArgs.back();
				for(int i=0;i<funcArgs.size();i++){
					if(funcArgs[i]=="...")break;
					if(tempArgs.size()==i){
						yyerror(("Too few Arguments to Function " + $1->tempName).c_str());
						return 0;
					}
					string msg = assignExp(funcArgs[i],tempArgs[i],"=");
					if(msg =="warning"){
						cout<<"Incompatible conversion of " +  tempArgs[i] + " to parameter of type " + funcArgs[i]<<endl;
					}
					else if(msg.empty()){
						yyerror(("Incompatible Argument to the function " + $1->tempName).c_str());
						$$->is_error = 1;
						return 0;
					}
					if(i==funcArgs.size()-1 && i<tempArgs.size()-1){
						yyerror(("Too many Arguments to Function " + $1->tempName).c_str());
						$$->is_error = 1;
						return 0;
					}
				}	
				//--3AC
				qid q = newtemp($$->type);
				$$->place = q;
				$$->nextlist.clear();
				emit(qid("CALL", NULL), qid($1->tempName,NULL), qid(to_string(currArgs.back().size()), NULL), q, -1);
				currArgs.pop_back();
				if(func_usage_map.find($1->tempName) != func_usage_map.end()){
					func_usage_map[$1->tempName] = 1;
				}
			}
		}
		else{
			yyerror("Invalid function call");
			$$->is_error=1;
		}
    }
    |Primary '.' SimpleName '(' ArgumentListy ')' {
        vector<data2>v;
        insertAttr(v, $1, "", 1);
        insertAttr(v, NULL, ".", 0);
        insertAttr(v,$3, "", 1);
        insertAttr(v, NULL, "(", 0);
        insertAttr(v,$5, "", 1);
        insertAttr(v, NULL, ")", 0);
		$$ = makenode("MethodInvocation", v);
    }
;

ArgumentList
    : Expression {
        $$=$1;

        if(!$1->is_error){
			//Semantic
			$$->isInit = $1->isInit;
			currArgs.back().push_back($1->type);
			$$->type = "void";

			//--3AC
			$$->nextlist.clear();
			int _idx = -1;
			if($$->type == "char*" && $$->place.second == NULL) _idx = -4;
			emit(qid("param", NULL), $$->place, qid("", NULL), qid("", NULL), _idx);
		}
		else{
			$$->is_error = 1;
		}
    }
    |ArgumentList ',' Expression {
        vector<data2>v;
        insertAttr(v,$1, "", 1);
        insertAttr(v,NULL, ",", 0);
        insertAttr(v,$3, "", 1);
		$$ = makenode("ArgumentList", v);

        //semantic
		if($1->isInit && $3->isInit) $$->isInit=1;
		currArgs.back().push_back($3->type);
		$$->type = "void";

		//3AC
			$$->nextlist.clear();
			int _idx = -1;
			backpatch($3->nextlist, code.size());
			if($3->type == "char*" && $3->place.second == NULL) _idx = -4;
			emit(qid("param", NULL), $3->place, qid("", NULL), qid("", NULL), _idx);
    }

ArrayCreationExpression
    :NEW PrimitiveType DimExprs Dimsy {
        vector<data2>v;
        insertAttr(v, makeleaf($1), "", 1);
        insertAttr(v,$2, "", 1);
        insertAttr(v,$3, "", 1);
        insertAttr(v,$4, "", 1);
		$$ = makenode("ArrayCreationExpression", v);
    }
    ;

DimExprs
    :DimExpr{$$=$1;}
    |DimExprs DimExpr{
        vector<data2>v;
        insertAttr(v,$1, "", 1);
        insertAttr(v,$2, "", 1);
		$$ = makenode("DimExprs", v);
    }
    ;


DimExpr
    :'[' Expression ']' {
        vector<data2>v;
        insertAttr(v, NULL, "[", 0);
        insertAttr(v,$2, "", 1);
        insertAttr(v, NULL, "]", 0);
		$$ = makenode("DimExpr", v);
    }
    ;

Expression
    :AssignmentExpression {$$ = $1;}
    ;


AssignmentExpression
    :Assignment {$$ = $1;}
    |ConditionalExpression {$$ = $1;}
    ;

Assignment
    :LeftHandSide AssignmentOperator {if_found = 0;} AssignmentExpression {
        vector<data2>v;
        insertAttr(v,$1, "", 1);
        insertAttr(v,$4, "", 1);
		$$ = makenode($2->tempName , v);

        //Semantics
		cout << "in Assignment\n";
		string temp = assignExp($1->type,$4->type,string($2->tempName));

		if($1->expType!=4){
			if(!temp.empty()){
				$$->type = $1->type;
				if($1->expType == 3 && $4->isInit){
					updInit($1->tempName);
				}
				
				// 3ac 
				int num = assign_exp($2->tempName, $$->type, $1->type, $4->type, $1->place, $4->place);
				$$->place = $1->place;
				backpatch($4->nextlist, num);
			}
			else{
				yyerror(("Incompatible types when assigning " + $4->type + " type to " + $1->type).c_str());
			}
		}
		else{
			if($1->expType==4){
				yyerror("Left operand in assignment operation cannot be a constant expression");
			}
		}
    }
    ;

LeftHandSide
    :Name {$$ = $1;}
    |ArrayAccess{$$=$1;}
    ;

AssignmentOperator
    :'='{$$ = makeleaf("=");
    $$->tempName = "=";}
    |DIV_ASSIGN {$$ = makeleaf($1);
    $$->tempName = string($1);
    }
    |MUL_ASSIGN {$$ = makeleaf($1);
    $$->tempName = string($1);
    }
    |MOD_ASSIGN{$$ = makeleaf($1);
    $$->tempName = string($1);
    }
    |ADD_ASSIGN{$$ = makeleaf($1);
    $$->tempName = string($1);
    }
    |SUB_ASSIGN{$$ = makeleaf($1);
    $$->tempName = string($1);
    }
    |LEFT_ASSIGN{$$ = makeleaf($1);
    $$->tempName = string($1);
    }
    |RIGHT_ASSIGN{$$ = makeleaf($1);
    $$->tempName = string($1);
    }
    |UNSIGNED_RIGHT_ASSIGN{$$ = makeleaf($1);
    $$->tempName = string($1);
    }
    |AND_ASSIGN{$$ = makeleaf($1);
    $$->tempName = string($1);
    }
    |XOR_ASSIGN{$$ = makeleaf($1);
    $$->tempName = string($1);
    }
    |OR_ASSIGN{$$ = makeleaf($1);
    $$->tempName = string($1);
    }
;

ConditionalExpression
    : GOTO_COND NEXT_QUAD Expression WRITE_GOTO ':' NEXT_QUAD ConditionalExpression {
        vector<data2>v;
        insertAttr(v,$1, "", 1);
        insertAttr(v,$3, "", 1);
        insertAttr(v, NULL, ":", 0);
        insertAttr(v,$7, "", 1);
		$$ = makenode("ConditionalExpression2", v);

        // Semantics
		if_found = previous_if_found;
		if($1->isInit == 0) {
			yyerror("Condition is not initialized");
		}
		if($1->intVal) {
			if($3->isInit == 0){
				yyerror("Expression is not initialized");
			}
			$$->type = $3->type;
			$$->intVal = $3->intVal;
		}
		else {
			if($7->isInit == 0){
				yyerror("Expression is not initialized");
			}
			$$->type = $7->type;
			$$->intVal = $7->intVal;
		}
		$$->isInit=1;

		// 3AC
		qid temp1 = newtemp($$->type);

		backpatch($1->truelist, $2);
		backpatch($1->falselist, $6);
		backpatch($3->nextlist, $4-1);
		backpatch($3->truelist, $4-1);
		backpatch($3->falselist, $4-1);

		code[$4-1].arg1 = $3->place;
		code[$4-1].res = temp1;

		backpatch($7->nextlist, code.size());
		backpatch($7->falselist, code.size());
		backpatch($7->truelist, code.size());

		emit(qid("=", NULL), $7->place, qid("", NULL), temp1, -1);
		$$->nextlist.push_back($4);
		$$->place = temp1;
    }
    |ConditionalOrExpression {$$=$1;}
    ;

GOTO_COND
	: ConditionalOrExpression '?' {
		previous_if_found = if_found;
		if_found = 0;
		$$ = $1;
		if($1->truelist.empty()){
			backpatch($1->nextlist, code.size());
			emit(qid("GOTO", NULL), qid("IF", lookup("if")), $1->place, qid("", NULL), 0);
			$1->truelist.push_back(code.size()-1);
			emit(qid("GOTO", NULL), qid("", NULL), qid("", NULL), qid("", NULL), 0);
			$1->falselist.push_back(code.size()-1);
		}
	}
	;

WRITE_GOTO
	: %empty {
		emit(qid("=", NULL), qid("", NULL), qid("", NULL), qid("", NULL), -1);
		emit(qid("GOTO", NULL), qid("", NULL), qid("", NULL), qid("", NULL), 0);
		$$ = code.size()-1;
	}
	;

ConditionalOrExpression
    : GOTO_OR NEXT_QUAD ConditionalAndExpression	{
		vector<data2> attr;
		insertAttr(attr, $1, "", 1);
		insertAttr(attr, $3, "", 1);
		$$ = makenode("||",attr);

		// Semantics

		if($1->type != "boolean" || $3->type != "boolean" ) {
			yyerror("Incorrect types used in conditional OR expression");
		}
		$$->type = "boolean";
		if($1->isInit == 0 || $3->isInit == 0 ) {
			yyerror("Uninitialized expressions used in the conditional OR expression");
		}
		$$->isInit = (($1->isInit) & ($3->isInit));   
		$$->intVal = $1->intVal || $3->intVal;

		// 3AC
			if($3->truelist.empty() && if_found){
				backpatch($3->nextlist, code.size());
				emit(qid("GOTO", NULL), qid("IF", lookup("if")), $3->place, qid("", NULL), 0);
				$3->truelist.push_back(code.size()-1);
				emit(qid("GOTO", NULL), qid("", NULL), qid("", NULL), qid("", NULL), 0);
				$3->falselist.push_back(code.size()-1);
			}
			else {
				qid tmp = newtemp($$->type);
				emit(qid("||", NULL), $1->place, $3->place, tmp, -1);
				$$->place = tmp;
			}
			backpatch($1->falselist, $2);
			$$->truelist = $1->truelist;
			$$->truelist.insert($$->truelist.end(), $3->truelist.begin(), $3->truelist.end());
			$$->falselist = $3->falselist;

	}
    |ConditionalAndExpression { $$ = $1 ; }
    ;

GOTO_OR
	: ConditionalOrExpression OR_OP {
		$$ = $1;
		if($1->truelist.empty() && if_found){
				backpatch($1->nextlist, code.size());
				emit(qid("GOTO", NULL), qid("IF", lookup("if")), $1->place, qid("", NULL), 0);
				$1->truelist.push_back(code.size()-1);
				emit(qid("GOTO", NULL), qid("", NULL), qid("", NULL), qid("", NULL), 0);
				$1->falselist.push_back(code.size()-1);
			}
	}
	;

ConditionalAndExpression
    :GOTO_AND NEXT_QUAD InclusiveOrExpression {
		vector<data2> attr;
		insertAttr(attr, $1, "", 1);
		insertAttr(attr, $3, "", 1);
		$$ = makenode("&&",attr);

		// Semantics
			if($1->type != "boolean" || $3->type != "boolean" ) {
				yyerror("Incorrect types used in conditional AND expression");
			}
			$$->type = "boolean";
			if($1->isInit == 0 || $3->isInit == 0 ) {
				yyerror("Uninitialized expressions used in the conditional AND expression");
			}
			$$->isInit = (($1->isInit) & ($3->isInit));   
			$$->intVal = $1->intVal || $3->intVal;

			// 3AC
			if($3->truelist.empty() && if_found){
				backpatch($3->nextlist, code.size());
				emit(qid("GOTO", NULL), qid("IF", lookup("if")), $3->place, qid("", NULL), 0);
				$3->truelist.push_back(code.size()-1);
				emit(qid("GOTO", NULL), qid("", NULL), qid("", NULL), qid("", NULL), 0);
				$3->falselist.push_back(code.size()-1);
			}
			else {
				qid tmp = newtemp($$->type);
				emit(qid("&&", NULL), $1->place, $3->place, tmp, -1);
				$$->place = tmp;
			}
			backpatch($1->truelist, $2);
			$$->truelist = $3->truelist;
			$$->falselist = $1->falselist;
			$$->falselist.insert($$->falselist.end(), $3->falselist.begin(), $3->falselist.end());
	}
    |InclusiveOrExpression { $$ = $1 ;}
    ;

GOTO_AND
	: ConditionalAndExpression AND_OP {
		$$ = $1;
		
		if($1->truelist.empty() && if_found){
				backpatch($1->nextlist, code.size());
				emit(qid("GOTO", NULL), qid("IF", lookup("if")), $1->place, qid("", NULL), 0);
				$1->truelist.push_back(code.size()-1);
				emit(qid("GOTO", NULL), qid("", NULL), qid("", NULL), qid("", NULL), 0);
				$1->falselist.push_back(code.size()-1);
			}
	}
	;

InclusiveOrExpression
    :InclusiveOrExpression '|' ExclusiveOrExpression {
        vector<data2>v;
        insertAttr(v,$1, "", 1);
        insertAttr(v, NULL, "|", 0);
        insertAttr(v,$3, "", 1);
		$$ = makenode("InclusiveOrExpression", v);

        //Semantics
		
		if($1->isInit ==1 && $3->isInit ==1) $$->isInit = 1;
		else {
			yyerror("Unitialized operands with OR operator");
		}
		string temp = bitExp($1->type,$3->type);

		if(!temp.empty()){
			$$->type = "boolean";	
			$$->intVal = $1->intVal | $3->intVal;

			// 3AC
			if($1->expType == 4 && $3->expType == 4){
				$$->place = qid(to_string($$->intVal), $1->place.second);
				$$->expType = 4;
			}
			else{
				qid temp1 = newtemp($$->type);
				emit(qid("|", NULL), $1->place, $3->place, temp1, -1);
				$$->place = temp1;
			}
			$$->nextlist.clear();
		}
		else{
			yyerror(("Invalid operands of types \'" + string($1->type) + "\' and \'" + string($3->type) + "\' to boolean").c_str());
		}
    }
    |ExclusiveOrExpression {$$ = $1;}
    ;
ExclusiveOrExpression
    :ExclusiveOrExpression '^' AndExpression {
        vector<data2>v;
        insertAttr(v,$1, "", 1);
        insertAttr(v, NULL, "^", 0);
        insertAttr(v,$3, "", 1);
		$$ = makenode("ExclusiveOrExpression", v);

        //Semantics
		if($1->isInit ==1 && $3->isInit ==1) $$->isInit = 1;
		string temp = bitExp($1->type,$3->type);

		if(!$1->is_error && !$3->is_error){
			if(!temp.empty()){
				if(temp =="ok"){
					$$->type = "int";
				}
				else $$->type = "int";

				$$->intVal = $1->intVal ^ $3->intVal;

				// 3AC
				if($1->expType == 4 && $3->expType == 4){
					$$->place = qid(to_string($$->intVal), $1->place.second);
					$$->expType = 4;
				}
				else{
					qid temp1 = newtemp($$->type);
					emit(qid("^", NULL), $1->place, $3->place, temp1, -1);
					$$->place = temp1; 
				}
				$$->nextlist.clear();
			}
			else{
				yyerror(("Invalid operands of types \'" + $1->type + "\' and \'" + $3->type + "\' to binary ^").c_str());
				$$->is_error = 1;
			}
		}
		else{
			$$->is_error = 1;
		}
    }
    |AndExpression {$$ = $1;}
    ;

AndExpression
    :AndExpression '&' EqualityExpression {
        vector<data2>v;
        insertAttr(v,$1, "", 1);
        insertAttr(v, NULL, "&", 0);
        insertAttr(v,$3, "", 1);
		$$ = makenode("AndExpression", v);

        //Semantics
		if($1->isInit ==1 && $3->isInit ==1) $$->isInit = 1;
		string temp = bitExp($1->type,$3->type);

		if(!$1->is_error && !$3->is_error){
			if(!temp.empty()){
				if(temp =="ok"){
					$$->type = "int";
				}
				else $$->type = "int";
				
				$$->intVal = $1->intVal & $3->intVal;

				// 3AC
				if($1->expType == 4 && $3->expType == 4){
					$$->place = qid(to_string($$->intVal), $1->place.second);
					$$->expType = 4;
				}
				else{
					qid temp1 = newtemp($$->type);
					emit(qid("&", NULL), $1->place, $3->place, temp1, -1);
					$$->place = temp1;
				}
				$$->nextlist.clear();
			}
			else{
				yyerror(("Invalid operands of types \'" + $1->type + "\' and \'" + $3->type + "\' to binary &").c_str());
				$$->is_error = 1;
			}
		}
		else{
			$$->is_error = 1;
		}
    }
    |EqualityExpression {$$ = $1;}
    ;

EqualityExpression
    :EqualityExpression EQ_OP RelationalExpression {
        vector<data2>v;
        insertAttr(v,$1, "", 1);
        insertAttr(v,makeleaf($2), "", 1);
        insertAttr(v,$3, "", 1);
		$$ = makenode("EqualityExpression", v);

        //Semantics
		if($1->isInit ==1 && $3->isInit ==1) $$->isInit = 1;
		string temp = relExp($1->type,$3->type);

		if(!$1->is_error && !$3->is_error){
			if(!temp.empty()){
				$$->type = "int";

				if($1->intVal == $3->intVal) $$->intVal = 1;
				else $$->intVal = 0;

				// 3AC
				if($1->expType == 4 && $3->expType == 4){
					$$->place = qid(to_string($$->intVal), $1->place.second);
					$$->expType = 4;
				}
				else{
					qid temp1 = newtemp($$->type);
					emit(qid("==", NULL), $1->place, $3->place, temp1, -1);
					$$->place = temp1;
				}
				$$->nextlist.clear();
			}
			else{
				yyerror(("Invalid operands of types \'" + $1->type + "\' and \'" + $3->type + "\' to binary ==").c_str());
				$$->is_error = 1;
			}
		}
		else{
			$$->is_error = 1;
		}
    }
    |EqualityExpression NE_OP RelationalExpression {
        vector<data2>v;
        insertAttr(v,$1, "", 1);
        insertAttr(v,makeleaf($2), "", 1);
        insertAttr(v,$3, "", 1);
		$$ = makenode("EqualityExpression", v);

        //Semantics
		if($1->isInit ==1 && $3->isInit ==1) $$->isInit = 1;
		string temp = relExp($1->type,$3->type);

		if(!$1->is_error && !$3->is_error){
			if(!temp.empty()){
				$$->type = "int";

				if($1->intVal != $3->intVal) $$->intVal = 1;
				else $$->intVal = 0;

				// 3AC
				if($1->expType == 4 && $3->expType == 4){
					$$->place = qid(to_string($$->intVal), $1->place.second);
					$$->expType = 4;
				}
				else{
					qid temp1 = newtemp($$->type);
					emit(qid("!=", NULL), $1->place, $3->place, temp1, -1);
					$$->place = temp1; 
				}
				$$->nextlist.clear();
			}
			else{
				yyerror(("Invalid operands of types \'" + $1->type + "\' and \'" + $3->type + "\' to binary !=").c_str());
				$$->is_error = 1;
			}
		}
		else{
			$$->is_error = 1;
		}

        
    }
    |RelationalExpression {$$ = $1 ;}
    ;

RelationalExpression
    :RelationalExpression '<' ShiftExpression  {
        vector<data2>v;
        insertAttr(v,$1, "", 1);
        insertAttr(v,NULL, "<", 0);
        insertAttr(v,$3, "", 1);
		$$ = makenode("RelationalExpression", v);


        //Semantic
		if($1->isInit ==1 && $3->isInit ==1) $$->isInit = 1;
		string temp = relExp($1->type,$3->type);

		if(!$1->is_error && !$3->is_error){
			if(!temp.empty()){
				if(temp == "bool"){
					$$->type = "int";
				}
				else if(temp == "Bool"){
					$$->type = "int";
				}

				if($1->intVal < $3->intVal) $$->intVal = 1;
				else $$->intVal = 0;

				// 3AC
				if($1->expType == 4 && $3->expType == 4){
					$$->place = qid(to_string($$->intVal), $1->place.second);
					$$->expType = 4;
				}
				else{
					qid temp1 = newtemp($$->type);
					emit(qid("<", NULL), $1->place, $3->place, temp1, -1);
					$$->place = temp1; 
				}
				$$->nextlist.clear();
				
			}
			else{
				yyerror(("Invalid operands of types \'" + $1->type + "\' and \'" + $3->type + "\' to binary <").c_str());
				$$->is_error = 1;
			}
		}
		else{
			$$->is_error = 1;
		}
    } 
    |RelationalExpression '>' ShiftExpression  {
        vector<data2>v;
        insertAttr(v,$1, "", 1);
        insertAttr(v,NULL, "<", 0);
        insertAttr(v,$3, "", 1);
		$$ = makenode("RelationalExpression", v);

        //semantic

		if($1->isInit ==1 && $3->isInit ==1) $$->isInit = 1;
		string temp = relExp($1->type,$3->type);

		if(!$1->is_error && !$3->is_error){
			if(!temp.empty()){
				if(temp == "bool"){
					$$->type = "int";
				}
				else if(temp == "Bool"){
					$$->type = "int";
				}

				if($1->intVal > $3->intVal) $$->intVal = 1;
				else $$->intVal = 0;
				// 3AC
				if($1->expType == 4 && $3->expType == 4){
					$$->place = qid(to_string($$->intVal), $1->place.second);
					$$->expType = 4;
				}
				else{
					qid temp1 = newtemp($$->type);
					emit(qid(">", NULL), $1->place, $3->place, temp1, -1);
					$$->place = temp1; 
				}
				$$->nextlist.clear();
			}
			else{
				yyerror(("Invalid operands of types \'" + $1->type + "\' and \'" + $3->type + "\' to binary >").c_str());
				$$->is_error = 1;
			}
		}
		else{
			$$->is_error = 1;
		}
    } 
    |RelationalExpression GE_OP ShiftExpression  {
        vector<data2>v;
        insertAttr(v,$1, "", 1);
        insertAttr(v,makeleaf($2), "", 1);
        insertAttr(v,$3, "", 1);
		$$ = makenode("RelationalExpression", v);

        //Semantic
		if($1->isInit ==1 && $3->isInit ==1) $$->isInit = 1;
		string temp = relExp($1->type,$3->type);

		if(!$1->is_error && !$3->is_error){
			if(!temp.empty()){
				if(temp == "bool"){
					$$->type = "int";
				}
				else if(temp == "Bool"){
					$$->type = "int";
				}
				if($1->intVal >= $3->intVal) $$->intVal = 1;
				else $$->intVal = 0;
				// 3AC
				$$->nextlist.clear();
				 
			}
			else{
				yyerror(("Invalid operands of types \'" + $1->type + "\' and \'" + $3->type + "\' to binary >=").c_str());
				$$->is_error = 1;
			}
		}
		else{
			$$->is_error = 1;
		}
    } 
    |RelationalExpression LE_OP ShiftExpression  {
        vector<data2>v;
        insertAttr(v,$1, "", 1);
        insertAttr(v,makeleaf($2), "", 1);
        insertAttr(v,$3, "", 1);
		$$ = makenode("RelationalExpression", v);

        //Semantic
		if($1->isInit ==1 && $3->isInit ==1) $$->isInit = 1;
		string temp = relExp($1->type,$3->type);

		if(!$1->is_error && !$3->is_error){
			if(!temp.empty()){
				if(temp == "bool"){
					$$->type = "int";
				}
				else if(temp == "Bool"){
					$$->type = "int";
				}
				if($1->intVal <= $3->intVal) $$->intVal = 1;
				else $$->intVal = 0;
				// 3AC
				$$->nextlist.clear();
			}
			else{
				yyerror(("Invalid operands of types \'" + $1->type + "\' and \'" + $3->type + "\' to binary <=").c_str());
				$$->is_error = 1;
			}
		}
		else{
			$$->is_error = 1;
		}
    }
    |ShiftExpression {$$ = $1;}
    ;


ShiftExpression
    :ShiftExpression LEFT_OP AdditiveExpression {
        vector<data2>v;
        insertAttr(v,$1, "", 1);
        insertAttr(v,makeleaf($2), "", 1);
        insertAttr(v,$3, "", 1);
		$$ = makenode("ShiftExpression", v);

		//Semantic
		if(!$1->is_error && !$3->is_error){
			if($1->isInit ==1 && $3->isInit ==1) $$->isInit = 1;
			string temp = shiftExp($1->type,$3->type);
			if(!temp.empty()){
				$$->type = $1->type;
				$$->intVal = $1->intVal << $3->intVal;
				$$->tempName = $1->tempName + " << " + $3->tempName;

				// 3AC
				if($1->expType == 4 && $3->expType == 4){
					$$->place = qid(to_string($$->intVal), $1->place.second);
					$$->expType = 4;
				}
				else{
					qid temp1 = newtemp($$->type);
					emit(qid("<<", NULL), $1->place, $3->place, temp1, -1);
					$$->place = temp1;
				}
				$$->nextlist.clear();
			}
			else{
				yyerror(("Invalid operands of types \'" + $1->type + "\' and \'" + $3->type + "\' to binary <<").c_str());
				$$->is_error = 1;
			}
		}
		else{
			$$->is_error = 1;
		}

    }
    |ShiftExpression RIGHT_OP AdditiveExpression {
        vector<data2>v;
        insertAttr(v,$1, "", 1);
        insertAttr(v,makeleaf($2), "", 1);
        insertAttr(v,$3, "", 1);
		$$ = makenode("ShiftExpression", v);

        //Semantic
		if($1->isInit ==1 && $3->isInit ==1) $$->isInit = 1;
		string temp = shiftExp($1->type,$3->type);

		if(!$1->is_error && !$3->is_error){
			if(!temp.empty()){
				$$->type = $1->type;
				$$->intVal = $1->intVal >> $3->intVal;
				$$->tempName = $1->tempName + " >> " + $3->tempName;

				// 3AC
				if($1->expType == 4 && $3->expType == 4){
					$$->place = qid(to_string($$->intVal), $1->place.second);
					$$->expType = 4;
				}
				else{
					qid temp1 = newtemp($$->type);
					emit(qid(">>", NULL), $1->place, $3->place, temp1, -1);
					$$->place = temp1;
				}
				$$->nextlist.clear();
				
			}
			else{
				yyerror(("Invalid operands of types \'" + $1->type + "\' and \'" + $3->type + "\' to binary >>").c_str());
				$$->is_error = 1;
			}
		}
		else{
			$$->is_error = 1;
		}
    }
    |ShiftExpression UNSIGNED_RIGHT AdditiveExpression {
        vector<data2>v;
        insertAttr(v,$1, "", 1);
        insertAttr(v,makeleaf($2), "", 1);
        insertAttr(v,$3, "", 1);
		$$ = makenode("ShiftExpression", v);

        yyerror("Not implemented yet!\n");

    }
    |AdditiveExpression {$$= $1;}
    ;

AdditiveExpression
    :AdditiveExpression '+' MultiplicativeExpression  {
        vector<data2>v;
        insertAttr(v,$1, "", 1);
        insertAttr(v,NULL, "+", 1);
        insertAttr(v,$3, "", 1);
		$$ = makenode("AdditiveExpression", v);
        
        //Semantic
		if($1->isInit ==1 && $3->isInit ==1) $$->isInit = 1;
		
		string temp = addExp($1->type,$3->type);
		
		if(!$1->is_error && !$3->is_error){
			if(!temp.empty()){
				if(temp == "int")	$$->type = "int";
				else if(temp == "real")	$$->type = "float";
				else $$->type =  temp;

				$$->intVal = $1->intVal + $3->intVal;
				$$->realVal = $1->realVal + $3->realVal;
				$$->tempName = $1->tempName + " + " + $3->tempName;

				// 3AC

				if($1->expType == 4 && $3->expType == 4){
					$$->place = qid(to_string($$->intVal), $1->place.second);
					$$->expType = 4;
				}
				else{
					qid temp1 = newtemp($$->type);
					int cond1 = (isInt($1->type) && isFloat($3->type));
					int cond2 = (isInt($3->type) && isFloat($1->type));

					if(cond1){
						qid temp2 = newtemp($3->type);
						emit(qid("inttoreal", NULL), $1->place, qid("", NULL), temp2, -1);
						emit(qid("+"+temp, NULL), temp2, $3->place, temp1, -1);
					}
					else if(cond2){
						qid temp2 = newtemp($1->type);
						emit(qid("inttoreal", NULL), $3->place, qid("", NULL), temp2, -1);
						emit(qid("+"+temp, NULL), $1->place, temp2, temp1, -1);
					}
					else{
						emit(qid("+"+temp, NULL), $1->place, $3->place, temp1, -1);
					}
					$$->place = temp1;
				}
				$$->nextlist.clear();
			}
			else{
				yyerror(("Incompatible types \'" + $1->type + "\' and \'" + $3->type + "\' for + operator").c_str());
				$$->is_error = 1;
			}
		}
		else{
			$$->is_error = 1;
		}
    }
    |AdditiveExpression '-' MultiplicativeExpression  {
        vector<data2>v;
        insertAttr(v,$1, "", 1);
        insertAttr(v,NULL, "-", 1);
        insertAttr(v,$3, "", 1);
		$$ = makenode("AdditiveExpression", v);

        //Semantic
		if($1->isInit ==1 && $3->isInit ==1) $$->isInit = 1;

		string temp = addExp($1->type,$3->type);
		if(!$1->is_error && !$3->is_error){
			if(!temp.empty()){
				if(temp == "int")$$->type = "int";
				else if(temp == "real")$$->type = "float";
				else $$->type = temp;

				$$->intVal = $1->intVal - $3->intVal;
				$$->realVal = $1->realVal - $3->realVal;
				$$->tempName = $1->tempName + " - " + $3->tempName;

				// 3AC

				if($1->expType == 4 && $3->expType == 4){
					$$->place = qid(to_string($$->intVal), $1->place.second);
					$$->expType = 4;
				}
				else{
					qid temp1 = newtemp($$->type);
					int cond1 = (isInt($1->type) && isFloat($3->type));
					int cond2 = (isInt($3->type) && isFloat($1->type));

					if(cond1){
						qid temp2 = newtemp($3->type);
						emit(qid("inttoreal", NULL), $1->place, qid("", NULL), temp2, -1);
						emit(qid("-"+temp, NULL), temp2, $3->place, temp1, -1);
					}
					else if(cond2){
						qid temp2 = newtemp($1->type);
						emit(qid("inttoreal", NULL), $3->place, qid("", NULL), temp2, -1);
						emit(qid("-"+temp, NULL), $1->place, temp2, temp1, -1);
					}
					else{
						emit(qid("-"+temp, NULL), $1->place, $3->place, temp1, -1);
					}
					$$->place = temp1;
				}
				$$->nextlist.clear();
				
			}
			else{
				yyerror(("Incompatible types \'" + $1->type + "\' and \'" + $3->type + "\' for - operator").c_str());
				$$->is_error = 1;
			}
		}
		else{
			$$->is_error = 1;
		}
	}
    |MultiplicativeExpression {$$ = $1;}
    ;


MultiplicativeExpression
    :MultiplicativeExpression '*' UnaryExpression {
        vector<data2>v;
        insertAttr(v,$1, "", 1);
        insertAttr(v,NULL, "*", 1);
        insertAttr(v,$3,"",1);
		$$ = makenode("MultiplicativeExpression", v);

        if(!($1->is_error || $3->is_error)){

			//Semantic
			$$->intVal = $1->intVal * $3->intVal; 

			if($1->isInit ==1 && $3->isInit ==1) $$->isInit = 1;
			string temp = mulExp($1->type, $3->type, '*');

			if(!temp.empty()){
				$$->type = temp;
				if($1->expType == 4 && $3->expType == 4){
					$$->place = qid(to_string($$->intVal), $1->place.second);
					$$->expType = 4;
				}
				else{
					if(temp == "int"){
						$$->type = "int" ;

						//--3AC
						qid q = newtemp("int");
						$$->place = q;
						$$->nextlist.clear();
						emit(qid("*int", NULL), $1->place, $3->place, q, -1);
					}
					else if(temp == "float"){
						$$->type = "float";

						//--3AC

						qid q = newtemp("float");
						$$->place = q;
						$$->nextlist.clear();

						if(isInt($1->type)){
							qid q1 = newtemp($$->type);
							emit(qid("inttoreal", NULL), $1->place, qid("", NULL), q1, -1);

							emit(qid("*real", NULL), q1, $3->place, q, -1);
						}
						else if(isInt($3->type)){
							qid q1 = newtemp($$->type);
							emit(qid("inttoreal", NULL), $3->place, qid("", NULL), q1, -1);
							emit(qid("*real", NULL), $1->place, q1, q, -1);
						}
						else{
							emit(qid("*real", NULL), $1->place, $3->place, q, -1);
						}
					}
				}
				$$->nextlist.clear();
			}
			else{
				yyerror(("Incompatible types \'" + $1->type + "\' and \'" + $3->type + "\' for * operator").c_str());
				$$->is_error = 1;
			}
		}
		else{
			$$->is_error = 1;
		}
    }
    |MultiplicativeExpression '/' UnaryExpression {
        vector<data2>v;
        insertAttr(v,$1, "", 1);
        insertAttr(v,NULL, "/", 1);
        insertAttr(v,$3,"",1);
		$$ = makenode("MultiplicativeExpression", v);

        if(!($1->is_error || $3->is_error)){
			//Semantic
			if($3->intVal!=0)$$->intVal = $1->intVal / $3->intVal;
			if($1->isInit ==1 && $3->isInit ==1) $$->isInit = 1;
			string temp =mulExp($1->type,$3->type,'/');
			if(!temp.empty()){
				$$->type = temp;

				if($1->expType == 4 && $3->expType == 4){
					$$->place = qid(to_string($$->intVal), $1->place.second);
					$$->expType = 4;
				}
				else{
					if(temp == "int"){
						$$->type = "int" ;

						//--3AC
						qid q = newtemp("int");
						$$->place = q;
						$$->nextlist.clear();
						emit(qid("/int", NULL), $1->place, $3->place, q, -1);
					}
					else if(temp == "float"){
						$$->type = "float";

						//--3AC
						qid q = newtemp("float");
						$$->place = q;
						$$->nextlist.clear();
						if(isInt($1->type)){
							qid q1 = newtemp($$->type);
							emit(qid("inttoreal", NULL), $1->place, qid("", NULL), q1, -1);

							emit(qid("/real", NULL), q1, $3->place, q, -1);
						}
						else if(isInt($3->type)){
							qid q1 = newtemp($$->type);
							emit(qid("inttoreal", NULL), $3->place, qid("", NULL), q1, -1);

							emit(qid("/real", NULL), $1->place, q1, q, -1);
						}
						else{
							emit(qid("/real", NULL), $1->place, $3->place, q, -1);
						}
					}
				}
				$$->nextlist.clear();
			}
			else{
				yyerror(("Incompatible types \'" + $1->type + "\' and \'" + $3->type + "\' for / operator").c_str());
				$$->is_error = 1;
			}
		}
		else{
			$$->is_error = 1;
		}

    }
    |MultiplicativeExpression '%' UnaryExpression {
        vector<data2>v;
        insertAttr(v,$1, "", 1);
        insertAttr(v,NULL, "%", 1);
        insertAttr(v,$3,"",1);
		$$ = makenode("MultiplicativeExpression", v);

        if(!($1->is_error || $3->is_error)){
			//Semantic
			if($1->isInit ==1 && $3->isInit ==1) $$->isInit = 1;
			if($3->intVal!=0)$$->intVal = $1->intVal % $3->intVal;
			string temp =mulExp($1->type,$3->type,'%');
			if(temp == "int"){
				$$->type = "int" ;

				//--3AC
				if($1->expType == 4 && $3->expType == 4){
					$$->place = qid(to_string($$->intVal), $1->place.second);
					$$->expType = 4;
				}
				else{
					qid q = newtemp("int");
					$$->place = q;
					emit(qid("%", NULL), $1->place, $3->place, q, -1);
				}
				$$->nextlist.clear();

			}
			else{
				yyerror(("Incompatible types \'" + $1->type + "\' and \'" + $3->type + "\' for % operator").c_str());
				$$->is_error = 1;
			}
		}
		else{
			$$->is_error = 1;
		}


    }
    |UnaryExpression {$$ = $1;}
    ;


UnaryExpression
    :PreIncrementExpression {$$ = $1;}
    |PreDecrementExpression {$$ = $1;}
    |'+' UnaryExpression {
        // $1=makeleaf("+");
        vector<data2>v;
        insertAttr(v, NULL, "+", 0);
        insertAttr(v,$2, "", 1);
		$$ = makenode("UnaryExpression", v);

        
        //Semantic
        // remember this line
		if(!($2->is_error)){
			$$->isInit = $2->isInit;
			string temp = unaryExp("+",$2->type);
			if(!temp.empty()){
				$$->type = temp;
				$$->intVal = $2->intVal;

				//--3AC
				qid q = newtemp(temp);
				$$->tempName = $2->tempName;
				$$->place = q;
				$$->nextlist.clear();
				emit(qid("unary+", lookup("+")),$2->place, qid("", NULL), q, -1);
			}
			else{
				yyerror("Type inconsistent with operator");
				$$->is_error = 1;
			}
		}
		else{
			$$->is_error = 1;
		}
    }
    |'-' UnaryExpression {
        vector<data2>v;
        insertAttr(v, NULL, "-", 0);
        insertAttr(v,$2, "", 1);
		$$ = makenode("UnaryExpression", v);

        

        //Semantic
		if(!($2->is_error)){
			$$->isInit = $2->isInit;
			string temp = unaryExp("-",$2->type);
			if(!temp.empty()){
				$$->type = temp;
				$$->intVal = $2->intVal;

				//--3AC
				qid q = newtemp(temp);
				$$->tempName = $2->tempName;
				$$->place = q;
				$$->nextlist.clear();
				emit(qid("unary-", lookup("-")),$2->place, qid("", NULL), q, -1);
			}
			else{
				yyerror("Type inconsistent with operator");
				$$->is_error = 1;
			}
		}
		else{
			$$->is_error = 1;
		}
    }
    |UnaryExpressionNotPlusMinus {$$ = $1;}
    ;

PreIncrementExpression
    :INC_OP UnaryExpression {
        vector<data2>v;
        insertAttr(v, makeleaf($1), "", 1);
        insertAttr(v,$2, "", 1);
		$$ = makenode("PreIncrementExpression", v);

        //Semantic
		if(!$2->is_error && $2->expType!=4){
			$$->isInit = $2->isInit;
			string temp = postfixExpression($2->type,6);
			
			if(!temp.empty()){
				$$->type = temp;
				$$->intVal = $2->intVal +1;

				//--3AC
				qid q = newtemp(temp);
				$$->place = q;
				$$->nextlist.clear();
				emit(qid("++P", NULL), $2->place, qid("", NULL), q, -1);
			}
			else{
				yyerror("Increment not defined for this type");
				$$->is_error = 1;
			}
		}
		else{
			if($2->expType==4){
				yyerror("constant expression cannot be used as lvalue");
			}
			$$->is_error = 1;
		}
    }
    ;

PreDecrementExpression
    :DEC_OP UnaryExpression {
        vector<data2>v;
        insertAttr(v, makeleaf($1), "", 1);
        insertAttr(v,$2, "", 1);
		$$ = makenode("PreDecrementExpression", v);

        //Semantic
		if(!$2->is_error && $2->expType!=4){
			$$->isInit = $2->isInit;
			string temp = postfixExpression($2->type,7);
			if(!temp.empty()){
				$$->type = temp;
				$$->intVal = $2->intVal -1;

				//--3AC
				qid q = newtemp(temp);
				$$->place = q;
				$$->nextlist.clear();
				emit(qid("--P", NULL), $2->place, qid("", NULL), q, -1);
			}
			else{
				yyerror("Decrement not defined for this type");
			}
		}
		else{
			if($2->expType==4){
				yyerror("constant expression cannot be used as lvalue");
			}
			$$->is_error = 1;
		}
    }
    ;

UnaryExpressionNotPlusMinus
    :PostfixExpression {$$ = $1;}

    |'~' UnaryExpression {
        vector<data2>v;
        insertAttr(v, NULL, "~", 0);
        insertAttr(v,$2, "", 1);
		$$ = makenode("UnaryExpressionNotPlusMinus", v);
        

        //semantic
        $$->place = qid("~", lookup("~"));

        if(!($2->is_error)){
			$$->isInit = $2->isInit;
			string temp = unaryExp("~",$2->type);
			if(!temp.empty()){
				$$->type = temp;
				$$->intVal = ~($2->intVal);

				//--3AC
				qid q = newtemp(temp);
				$$->tempName = $2->tempName;
				$$->place = q;
				$$->nextlist.clear();
				emit(qid("~", lookup("~")), $2->place, qid("", NULL), q, -1);
			}
			else{
				yyerror("Type inconsistent with operator");
				$$->is_error = 1;
			}
		}
		else{
			$$->is_error = 1;
		}
    }
    |'!' UnaryExpression {
        vector<data2>v;
        insertAttr(v, NULL, "!", 0);
        insertAttr(v,$2, "", 1);
		$$ = makenode("UnaryExpressionNotPlusMinus", v);

        //semantic

        if(! ($2->is_error)){
			$$->isInit = $2->isInit;
			string temp = unaryExp("!",$2->type);
			if(!temp.empty()){
				$$->type = temp;
				$$->intVal = !($2->intVal);

				//--3AC
				qid q = newtemp(temp);
				$$->tempName = $2->tempName;
				$$->place = q;
				$$->nextlist.clear();
				emit(qid("~", lookup("~")), $2->place, qid("", NULL), q, -1);
			}
			else{
				yyerror("Type inconsistent with operator");
				$$->is_error = 1;
			}
		}
		else{
			$$->is_error = 1;
		}
    }
    |CastExpression {$$ = $1;}
    ;

PostfixExpression
    :Primary {$$ = $1;}
    |Name {$$ = $1;}
    |PostIncrementExpression { $$ = $1 ;}
    |PostDecrementExpression { $$ = $1 ;}
    ;

PostIncrementExpression
    :PostfixExpression INC_OP {
        vector<data2>v;
        insertAttr(v,$1, "", 1);
        insertAttr(v, makeleaf($2), "", 1);
		$$ = makenode("PostIncrementExpression", v);

        //Semantics
		$$->isInit = $1->isInit;
		if(!$1->is_error && $1->expType!=4){
			string temp = postfixExpression($1->type,6);
			if(!temp.empty()){
				$$->type = temp;
				$$->intVal = $1->intVal + 1;

				//--3AC

				qid q = newtemp(temp);
				$$->place = q;
				$$->nextlist.clear();
				emit(qid("++S", NULL), $1->place, qid("", NULL), q, -1);
			}
			else{
				yyerror("Increment not defined for this type");
				$$->is_error = 1;
			}
		}
		else{
			if($1->expType==4){
				yyerror("constant expression cannot be used as lvalue");
			}

			$$->is_error = 1;
		}
    }
    ;

PostDecrementExpression
    :PostfixExpression DEC_OP {
        vector<data2>v;
        insertAttr(v,$1, "", 1);
        insertAttr(v, makeleaf($2), "", 1);
		$$ = makenode("PostDecrementExpression", v);

        //Semantics
		if(!$1->is_error && $1->expType!=4){
			$$->isInit = $1->isInit;
			string temp = postfixExpression($1->type,7);
			if(!temp.empty()){
				$$->type = temp;
				$$->intVal = $1->intVal - 1;

				//--3AC

				qid q = newtemp(temp);
				$$->place = q;
				$$->nextlist.clear();
				emit(qid("--S", NULL), $1->place, qid("", NULL), q, -1);

			}
			else{
				yyerror("Decrement not defined for this type");
				$$->is_error = 1;
			}
		}
		else{
			if($1->expType==4){
				yyerror("constant expression cannot be used as lvalue");
			}
			$$->is_error = 1;
		}

    }
    ;

CastExpression
    : '(' PrimitiveType ')' UnaryExpression  { // 1
        vector<data2>v;
        insertAttr(v, NULL, "(", 0);
        insertAttr(v,$2, "", 1);
        insertAttr(v, NULL, ")", 0);
        insertAttr(v,$4, "", 1);
		$$ = makenode("CastExpression", v);
    }
    ;


G 	
    : Identifier 	{
		$$ = makeleaf($1);
		$$->tempName = string($1);
		className = $1;
		classTemp = className ; 
	}
    ;

S 
    : %empty {
		createStructTable();
		if(type != "") {
			yyerror(("cannot combine with previous " + type + " declaration specifier").c_str());
		}
	}
    ;

NEXT_QUAD
	: %empty {
		$$ = code.size();
	}
	;

ChangeTable
	: %empty {
		$$=NULL;
		// string str = "Block" +to_string(block_count);
		string str = funcName;
		block_stack.push(block_count);
		block_count++;
		// func_flag++;
		makeSymbolTable(str, type,0);
	}
	;

A
	: %empty	{
		$$=NULL;
		type ="";
		// func_flag = 0;
		funcArgs.clear();
		createParamList();
		gotolablelist.clear();
		gotolabel.clear();
	}


%%
    
int main(int argc, char* argv[]){

    dotfile=fopen(argv[1],"w");
    code_file.open("final.txt");

    if(dotfile == NULL){
		cout<<"cannot open the dot file AST.dot"<<"\nCompilation terminated\n";
		return -1;
	}
	

    symTable_init();
	beginAST();
    yyparse();
/* 
    for(int i=2; i<argc; i++){
        if(!strcmp(argv[i], "-dump-sym-table")) dump_sym_table = 1;
		else if(!strcmp(argv[i], "-dump-tac")) dump_tac = 1;
		else if(!strcmp(argv[i], "-dump-all")) dump_tac = dump_sym_table = 1;
    } */

    setGlobal();
	print3AC();
	genCode();
	endAST();
	if(dump_sym_table) printSymbolTable(&globalst, "Global_Symbol_Table.csv");
    return 0;
}

void yyerror(char const* s){
    cout << "Error: " << s << " in Line no: " << line << endl;
    exit(-1);
}

// set type as int and read integer value correctly depending on the base
void set_int_type(int t){
	yylval.num = new constants;
	yylval.num->str = strdup(yytext);
	yylval.num->type = string("int");
	switch(t){
		// 3-> hexadecimal, 2-> octal, 1-> decimal, 0-> char
		case 0 : {
			sscanf(yytext, "%", &(yylval.num->intVal));
			yylval.num->intVal = char_int(yylval.num->str);
			yylval.num->type = "char";
			break;
		}
		case 1 : {
			sscanf(yytext, "%lld", &(yylval.num->intVal));
			break;
		}
		case 2 : {
			sscanf(yytext, "%llo", &(yylval.num->intVal));
			break;
		}
		case 3 : {
			sscanf(yytext, "%llx", &(yylval.num->intVal));
			break;
		}
	}
}

// convert character to an integer value
int char_int(string str){
    if(str[1] == '\\'){
        string s = str.substr(1,2);
        if(s == "\\0") return 0;
        if(s == "\\n") return 10;
        if(s == "\\t") return 9;
    } 
    int val = (int)str[1];
    return (val);
}

// set type as float and read the real value
void set_real_type(){
	yylval.num = new constants ;
	yylval.num->str = strdup(yytext);
	yylval.num->type = string("float");
	sscanf(yytext, "%lf", &(yylval.num->realVal));
} 